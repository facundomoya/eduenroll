1. Trabajar en cascada borra un registro de la tabla hija y lo borra de la tabla padre (ej: user y administrator)
2. JWT revisar bien como se llega al token
3. El borrado nunca es fisico siempre logico, se actualiza la columna delete_at, pero no se borra nada fisicamente, 
si no que desde el frontend solo trae los que tienen vacio ese campo en el registro
4. zod es para validaciÃ³n de los datos (librerÃ­a) - esto pertenece a la carpeta validator, alli es donde se hacen las validaciones

ğŸ“Œ Â¿CuÃ¡l es la funciÃ³n de cada uno?
auth.services.js (Login)
Este archivo se encarga de autenticar al usuario.

Si el usuario existe y las credenciales son correctas:

Genera un token JWT usando jwt.sign().

Retorna el token al frontend (por ejemplo, Postman o una app web).

Este archivo va primero en el flujo: es el que inicia la autenticaciÃ³n.

verifyToken.js (Middleware de verificaciÃ³n)
Este archivo se usa para proteger rutas privadas.

Recibe el token enviado por el cliente en el header (Authorization: Bearer <token>).

Verifica si el token es vÃ¡lido y si el usuario existe.

Si todo estÃ¡ bien, deja pasar la peticiÃ³n (next()); si no, lanza un error.

Este va despuÃ©s, cuando se accede a una ruta protegida tras hacer login.

 Flujo completo resumido
ğŸ” Login con authServices.login(params)

Llamado desde un controlador de login (ej. /api/auth/login).

Si las credenciales son vÃ¡lidas:

Devuelve { token, user }.

ğŸ“¬ Cliente (Postman o frontend) recibe el token

Lo guarda localmente y lo usarÃ¡ en prÃ³ximas peticiones.

ğŸ“¤ Cliente hace peticiones a rutas protegidas

Incluye el token en el header:
Authorization: Bearer <token>.

ğŸ›¡ï¸ verifyToken.js actÃºa como middleware

Lee y verifica el token.

Busca al usuario por decoded.id.

Si es vÃ¡lido, aÃ±ade req.user y continÃºa.

Â¿DÃ³nde se conectan?

No se "llaman" directamente entre sÃ­, pero se complementan:

auth.services.js â†’ emite el token

verifyToken.js â†’ valida ese token

assets - seeders
