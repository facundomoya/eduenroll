1. Trabajar en cascada borra un registro de la tabla hija y lo borra de la tabla padre (ej: user y administrator)
2. JWT revisar bien como se llega al token
3. El borrado nunca es fisico siempre logico, se actualiza la columna delete_at, pero no se borra nada fisicamente, 
si no que desde el frontend solo trae los que tienen vacio ese campo en el registro
4. zod es para validación de los datos (librería) - esto pertenece a la carpeta validator, alli es donde se hacen las validaciones

📌 ¿Cuál es la función de cada uno?
auth.services.js (Login)
Este archivo se encarga de autenticar al usuario.

Si el usuario existe y las credenciales son correctas:

Genera un token JWT usando jwt.sign().

Retorna el token al frontend (por ejemplo, Postman o una app web).

Este archivo va primero en el flujo: es el que inicia la autenticación.

verifyToken.js (Middleware de verificación)
Este archivo se usa para proteger rutas privadas.

Recibe el token enviado por el cliente en el header (Authorization: Bearer <token>).

Verifica si el token es válido y si el usuario existe.

Si todo está bien, deja pasar la petición (next()); si no, lanza un error.

Este va después, cuando se accede a una ruta protegida tras hacer login.

 Flujo completo resumido
🔐 Login con authServices.login(params)

Llamado desde un controlador de login (ej. /api/auth/login).

Si las credenciales son válidas:

Devuelve { token, user }.

📬 Cliente (Postman o frontend) recibe el token

Lo guarda localmente y lo usará en próximas peticiones.

📤 Cliente hace peticiones a rutas protegidas

Incluye el token en el header:
Authorization: Bearer <token>.

🛡️ verifyToken.js actúa como middleware

Lee y verifica el token.

Busca al usuario por decoded.id.

Si es válido, añade req.user y continúa.

¿Dónde se conectan?

No se "llaman" directamente entre sí, pero se complementan:

auth.services.js → emite el token

verifyToken.js → valida ese token

assets - seeders
